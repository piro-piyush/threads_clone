import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:thread_clone/services/auth_service.dart';
import 'package:thread_clone/services/navigation_service.dart';
import 'package:thread_clone/services/threads_service.dart';
import 'package:thread_clone/utils/env.dart';
import 'package:thread_clone/utils/helper.dart';

/// CreateThreadController handles the complete lifecycle
/// of creating a new thread.
///
/// Responsibilities:
/// - Manage user metadata (name & avatar)
/// - Handle thread content & validation
/// - Manage image selection & removal
/// - Upload media to storage
/// - Create thread entry in backend
///
/// Built using GetX with reactive state management
/// for smooth UI updates.
class CreateThreadController extends GetxController {
  /// Auth service to access current user info
  final AuthService authService = Get.find<AuthService>();

  // ---------------- USER INFO ----------------

  /// Reactive display name of the current user
  final RxString name = ''.obs;

  /// Reactive profile image URL of the user (nullable)
  final RxnString userImageUrl = RxnString(null);

  // ---------------- THREAD CONTENT ----------------

  /// Text controller for thread input field
  final TextEditingController controller = TextEditingController();

  /// Form key for thread validation
  final GlobalKey<FormState> formKey = GlobalKey<FormState>();

  // ---------------- IMAGE ----------------

  /// Selected image file for the thread (single image)
  final Rxn<File> image = Rxn<File>();

  // ---------------- STATE ----------------

  /// Loading indicator for thread creation
  final RxBool isLoading = false.obs;

  /// Thread service for API & storage operations
  final ThreadsService threadsService = Get.find<ThreadsService>();

  @override
  void onInit() {
    super.onInit();

    /// Initialize reactive user info from auth metadata
    name.value = authService.user?.userMetadata?['name'] ?? '';
    userImageUrl.value = authService.user?.userMetadata?['image_url'] ?? '';
  }

  // ---------------- IMAGE MANAGEMENT ----------------

  /// Opens image picker bottom sheet and selects an image.
  ///
  /// Updates reactive image state if selection is successful.
  Future<void> addImage() async {
    final source = await openImagePickerSheet();
    if (source != null) {
      final pickedImage = await pickImage(source);
      if (pickedImage != null) {
        image.value = File(pickedImage.path);
      }
    }
  }

  /// Removes the currently selected image.
  void removeImage() {
    image.value = null;
  }

  // ---------------- VALIDATION ----------------

  /// Validates thread content.
  ///
  /// Rules:
  /// - Cannot be empty
  /// - Max 500 characters
  String? validateThread(String? value) {
    if (value == null || value.trim().isEmpty) {
      return "Thread content cannot be empty";
    }
    if (value.trim().length > 500) {
      return "Thread content cannot exceed 500 characters";
    }
    return null;
  }

  // ---------------- CREATE THREAD ----------------

  /// Creates a new thread.
  ///
  /// Flow:
  /// 1. Validate form
  /// 2. Upload image (if exists)
  /// 3. Create thread record in DB
  /// 4. Reset UI & navigate back
  ///
  /// Includes granular error handling for:
  /// - Storage failures
  /// - Auth issues
  /// - Unexpected runtime errors
  Future<void> createThread() async {
    if (isLoading.value) return;
    if (!formKey.currentState!.validate()) return;

    isLoading.value = true;

    try {
      String? uploadedImageUrl;

      /// Upload image if selected
      if (image.value != null) {
        uploadedImageUrl = await threadsService.uploadThreadImage(
          file: image.value!,
          bucket: Env.s3Bucket,
        );
      }

      /// Insert thread (ID auto-generated by DB)
      await threadsService.createThread(
        content: controller.text.trim(),
        image: uploadedImageUrl,
        allowReplies: true,
      );

      /// Reset UI state
      controller.clear();
      image.value = null;

      /// Navigate back to previous tab/screen
      Get.find<NavigationService>().backToPrevIndex();

      showSnackBar("Success", "Thread posted successfully ✅");
    } catch (e, s) {
      debugPrint("❌ Error creating thread: $e");
      debugPrintStack(stackTrace: s);
      showSnackBar("Error", "Failed to post thread ❌");
    } finally {
      isLoading.value = false;
    }
  }
}
